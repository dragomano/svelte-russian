---
title: $derived
origin: https://svelte.dev/docs/svelte/$derived
sidebar:
  order: 2
---

Производное состояние объявляется с помощью руны `$derived`:

```svelte
<script>
  let count = $state(0);
  let doubled = $derived(count * 2);
</script>

<button onclick={() => count++}>
  {doubled}
</button>

<p>{count} вдвое больше — это {doubled}</p>
```

Выражение внутри `$derived(...)` должно быть свободно от побочных эффектов. Svelte не позволит изменения состояния (например, `count++`) внутри производных выражений.

Как и при использовании `$state`, вы можете пометить поля класса как `$derived`.

:::note
Код в компонентах Svelte выполняется только один раз при создании. Без руны `$derived` значение `doubled` сохраняло бы свое первоначальное значение, даже когда `count` изменяется.
:::

## `$derived.by`

Иногда вам нужно создать сложные производные, которые не помещаются в короткое выражение. В таких случаях вы можете использовать `$derived.by`, который принимает функцию в качестве аргумента.

```svelte
<script>
  let numbers = $state([1, 2, 3]);
  let total = $derived.by(() => {
    let total = 0;
    for (const n of numbers) {
      total += n;
    }
    return total;
  });
</script>

<button onclick={() => numbers.push(numbers.length + 1)}>
  {numbers.join(' + ')} = {total}
</button>
```

По сути, `$derived(expression)` эквивалентно `$derived.by(() => expression)`.

## Понимание зависимостей

Всё, что читается синхронно внутри выражения `$derived` (или тела функции `$derived.by`), считается _зависимостью_ производного состояния. Когда состояние изменяется, производное будет помечено как _грязное_ и пересчитано при следующем чтении.

Чтобы исключить часть состояния из обработки как зависимость, используйте [`untrack`](https://svelte.dev/docs/svelte/svelte#untrack).

## Обновление данных

Svelte использует механизм, известный как _реактивность с пуш-пулом_ — когда состояние изменяется, все, что связано с этим состоянием (прямо или косвенно), немедленно получает уведомление об изменении (пуш), но производные значения не пересчитываются, пока они не будут фактически запрошены (пул).

Если новое значение производного совпадает с предыдущим по ссылке, обновления для зависимых компонентов будут пропущены. То есть, Svelte обновит текст внутри кнопки только тогда, когда изменится `large`, а не `count`, даже несмотря на то, что `large` зависит от `count`:

```svelte
<script>
  let count = $state(0);
  let large = $derived(count > 10);
</script>

<button onclick={() => count++}>
  {large}
</button>
```
